// Copyright 2022 The CCGO Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package ccgo // import "modernc.org/ccgo/v4/lib"

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"sort"
	"strings"

	"golang.org/x/mod/semver"
	"modernc.org/cc/v4"
	"modernc.org/sortutil"
)

type name int

const (
	//  package __ccgo_object_file_v1
	objectFilePackageName       = objectFilePackageNamePrefix + objectFileSemver
	objectFilePackageNamePrefix = "__ccgo_object_file_"
	objectFileSemver            = "v1"
)

const (
	ccgo name = iota
	define
	enumTag
	enumerator
	external
	imports
	internal
	none
	structTag
	typename
	unionTag
	unpinned
)

var (
	// Don't change the association once established, otherwise the major
	// objectFileSemver must be incremented.
	//
	// The concatenation of a tag and a valid C identifier must not create a Go
	// keyword.
	tags = [...]string{
		ccgo:       "_",  // auto generated identifiers _0, _1 etc.
		define:     "df", // #define
		enumTag:    "te", // tagged enum
		enumerator: "ec", // enumerator constant
		external:   "X",  // external linkage
		imports:    "iq", // import qualifier
		internal:   "il", // internal linkage
		none:       "ln", // linkage none
		structTag:  "ts", // tagged struct
		typename:   "tn", // type name
		unionTag:   "tu", // tagged union
		unpinned:   "un", // unpinned
	}
)

func init() {
	if !semver.IsValid(objectFileSemver) {
		panic(todo("internal error: invalid objectFileSemver: %q", objectFileSemver))
	}
}

func tag(nm name) string { return tags[nm] }

// errHandler is a function called on error.
type errHandler func(msg string, args ...interface{})

type ctx struct {
	ast     *cc.AST
	cfg     *cc.Config
	eh      errHandler
	imports map[string]string // import path: qualifier
	out     io.Writer
	task    *Task

	closed bool
}

func newCtx(task *Task, eh errHandler) *ctx {
	return &ctx{
		cfg:     task.cfg,
		eh:      eh,
		imports: map[string]string{},
		task:    task,
	}
}

func (c *ctx) err(err error) { c.eh(err.Error()) }

func (c ctx) w(s string, args ...interface{}) {
	if c.closed {
		return
	}

	if _, err := fmt.Fprintf(c.out, s, args...); err != nil {
		c.err(err)
		c.closed = true
	}
}

func (c *ctx) compile(ifn, ofn string) error {
	f, err := os.Create(ofn)
	if err != nil {
		return err
	}

	defer func() {
		if err := f.Close(); err != nil {
			c.err(errorf("%v", err))
			return
		}

		if err := exec.Command("gofmt", "-w", "-r", "(x) -> x", ofn).Run(); err != nil {
			c.err(errorf("%v", err))
		}
	}()

	w := bufio.NewWriter(f)
	c.out = w

	defer func() {
		if err := w.Flush(); err != nil {
			c.err(errorf("%v", err))
		}
	}()

	sources := []cc.Source{
		{Name: "<predefined>", Value: c.cfg.Predefined},
		{Name: "<builtin>", Value: builtin},
	}
	if c.task.defs != "" {
		sources = append(sources, cc.Source{Name: "<command-line>", Value: c.task.defs})
	}
	sources = append(sources, cc.Source{Name: ifn, FS: c.cfg.FS})
	if c.ast, err = cc.Translate(c.cfg, sources); err != nil {
		return err
	}

	c.prologue()
	// for n := c.ast.TranslationUnit; n != nil; n = n.TranslationUnit {
	// 	c.externalDeclaration(n.ExternalDeclaration)
	// }
	return nil
}

func (c *ctx) prologue() {
	c.w(`// Code generated by '%s %s', DO NOT EDIT.

//go:build ignore
// +build ignore

// Compiled for %s/%s.

package %s
`,
		filepath.Base(c.task.args[0]),
		strings.Join(c.task.args[1:], " "),
		c.task.goos, c.task.goarch,
		objectFilePackageName,
	)
	var a []string
	if len(a) == 0 {
		return
	}

	a = a[:sortutil.Dedupe(sort.StringSlice(a))]
	var ns ns
	c.w("\nimport (")
	for _, v := range a {
		q := tag(imports) + ns.take(path.Base(v))
		c.imports[v] = q
		c.w("\t%s %q\n", q, v)
	}
	c.w("\n)")
}

func (c *ctx) externalDeclaration(n *cc.ExternalDeclaration) {
	switch n.Case {
	case cc.ExternalDeclarationFuncDef: // FunctionDefinition
		c.err(errorf("TODO %v", n.Case))
	case cc.ExternalDeclarationDecl: // Declaration
		c.declaration(n.Declaration)
	case cc.ExternalDeclarationAsmStmt: // AsmStatement
		c.err(errorf("TODO %v", n.Case))
	case cc.ExternalDeclarationEmpty: // ';'
		c.err(errorf("TODO %v", n.Case))
	default:
		c.err(errorf("internal error %T %v", n, n.Case))
	}
}

func (c *ctx) declaration(n *cc.Declaration) {
	switch n.Case {
	case cc.DeclarationDecl: // DeclarationSpecifiers InitDeclaratorList AttributeSpecifierList ';'
		switch {
		case n.InitDeclaratorList == nil:
			c.err(errorf("TODO %v", n.Case))
		default:
			for l := n.InitDeclaratorList; l != nil; l = l.InitDeclaratorList {
				c.initDeclarator(l.InitDeclarator)
			}
		}
	case cc.DeclarationAssert: // StaticAssertDeclaration
		c.err(errorf("TODO %v", n.Case))
	case cc.DeclarationAuto: // "__auto_type" Declarator '=' Initializer ';'
		c.err(errorf("TODO %v", n.Case))
	default:
		c.err(errorf("internal error %T %v", n, n.Case))
	}
}

func (c *ctx) initDeclarator(n *cc.InitDeclarator) {
	d := n.Declarator
	if d.IsExtern() {
		return
	}

	switch n.Case {
	case cc.InitDeclaratorDecl: // Declarator Asm
		switch {
		case d.IsTypename():
			// trc("", d.Position(), d.Name(), d.Type())
			c.err(errorf("TODO %v", n.Case))
		default:
			// trc("", d.Position(), d.Name(), d.Type())
			c.err(errorf("TODO %v", n.Case))
		}
	case cc.InitDeclaratorInit: // Declarator Asm '=' Initializer
		c.err(errorf("TODO %v", n.Case))
	default:
		c.err(errorf("internal error %T %v", n, n.Case))
	}
}
